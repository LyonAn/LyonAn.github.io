<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>LyonAn</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-03-29T05:33:42.555Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LyonAn</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Oracle 学习笔记01</title>
    <link href="http://yoursite.com/2018/03/20/oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B001/"/>
    <id>http://yoursite.com/2018/03/20/oracle学习笔记01/</id>
    <published>2018-03-20T05:06:48.000Z</published>
    <updated>2018-03-29T05:33:42.555Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Oracle-数据库"><a href="#Oracle-数据库" class="headerlink" title="Oracle 数据库"></a>Oracle 数据库</h2><h3 id="修改表"><a href="#修改表" class="headerlink" title="修改表"></a>修改表</h3><ol><li><p>修改表名<br>RENAME old_name TO new_name</p></li><li><p>修改表结构</p><ul><li>添加列<br>为 myemp 添加一列 hiredate :<br><code>ALTER TABLE myemp ADD (hiredate DATE DEFAULT SYSDATE )</code></li><li>删除列<br>删除上面添加的字段<br><code>ALTER TABLE myemp DROP(hiredate)</code></li><li>修改列<br><code>ALTER TABLE myemp MODIFY(job VARCHAR2(40) DEFAULT &#39;CLERK&#39;)</code></li></ul></li></ol><hr><h3 id="DML-语句"><a href="#DML-语句" class="headerlink" title="DML 语句"></a>DML 语句</h3><blockquote><p>DML 可以对表中的数据进行操作,分为 : INSERT, UPDATE , DELETE<br>DML 是伴随事务 ( Transaction ) 使用的.</p><p>####1.  INSERT<br><code>INSERT INTO myemp (id, name, salary, job) VALUES (1, &#39;jack&#39;, 5000, &#39;CLERK&#39; )</code><br>若不指定字段,则需全列插入<br><code>INSERT INTO myemp VALUES(...)</code><br>插入一个日期值<br><code>INSERT INTO myemp (id, name, salary, birth, job) VALUES (2, &#39;tom&#39;, 3000, TO_DATE(&#39;2008-08-08&#39;,&#39;YYYY-MM-DD&#39;))</code></p><h4 id="2-UPDATE"><a href="#2-UPDATE" class="headerlink" title="2. UPDATE"></a>2. UPDATE</h4><p>修改表中现有数据<br><code>UPDATE myemp SET gender=&#39;F&#39;, salary=9000 WHRER name=&#39;jack&#39;</code></p><h4 id="3-DELETE"><a href="#3-DELETE" class="headerlink" title="3. DELETE"></a>3. DELETE</h4><p>删除数据<br>通常使用时添加 WHERE 条件,不添加则是清空表</p></blockquote><hr><h3 id="DQL-语句"><a href="#DQL-语句" class="headerlink" title="DQL 语句"></a>DQL 语句</h3><h4 id="1-SELECT"><a href="#1-SELECT" class="headerlink" title="1. SELECT"></a>1. SELECT</h4><blockquote><p>查看表中所有字段及其记录<br><code>SELECT * FROM emp</code><br>查看表中的某几个字段<br><code>SELECT ename, job, sal FROM emp</code><br>SELECT 子句可以查看:字段,函数,表达式<br><code>SELECT ename, sal*12 FROM emp</code><br>SELECT 子句结合 WHERE 子句<br><code>SELECT ename, job,sal,deptno FROM emp WHERE deptno=20</code></p></blockquote><h4 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h4><ul><li><p><strong>CONCAT(P1,P2)</strong> : 字符串拼接<br><code>SELECT CONCAT(ename, sal) FROM emp;</code></p></li><li><p><strong>p1 || p2 || p3</strong>: 多字符拼接<br><code>SELECT ename||&#39;:&#39;||sal FROM emp</code></p></li><li><p><strong>LENGTH (p)</strong>: 获取字符串长度<br><code>SELECT ename, LENGTH(ename) FROM emp</code></p></li><li><p><strong>LOWER, UPPER, INICAP</strong> :小写,大写,首字母大写<br><code>SELECT LOWER(&#39;HELLO WORLD&#39;), UPPER(&#39;helloworld&#39;), INITCAP(&#39;hello world&#39;) FROM dual</code></p><blockquote><p>伪表 : dual<br>当查询内容与任何一张表无关时,为了满足 FROM子句的要求,可以使用伪表,伪表只会查出一条语句</p></blockquote></li><li><p><strong>TRIM , LTRIM, RTRIM</strong>:去除字符串两边内容 (注意语法)<br><code>SELECT TRIM(&#39;e&#39; FROM &#39;eeeeliteeee&#39;) FROM emp</code><br><code>SELECT LTRIM(&#39;esesesliteeee&#39;,&#39;es&#39;) FROM dual</code><br><code>SELECT RTRIM(&#39;eeeeliteeee&#39;,&#39;e&#39;) FROM dual</code></p></li><li><p><strong>LPAD, RPAD</strong></p><blockquote><p>补位函数,可以将指定内容指定位数,不足时则补充若干个指定的定义字符以达到位数</p></blockquote><p> <code>SELECT LPAD(sal,6,&#39;$&#39;) FROM emp</code><br><code>SELECT RPAD(sal,6,&#39; &#39;) FROM emp</code></p></li><li><p><strong>SUBSTR(str,m[,n])</strong></p><blockquote><p>截取字符串 str 从m处开始,,连续截取n个,若不指定n,则是连续截取到字符串末尾<br>注意:数据库中下标从 1 开始</p></blockquote><p> <code>SELECT SUBSTR(&#39;thinking in java&#39;,10,2) FROM dual</code></p></li><li><p><strong>INSTR(str1, str2 [,n [,m]])</strong></p><blockquote><p>查找位置 : 查找 str2 在 str1 中的位置,若指定了位置 n  从 n 处开始查找第一次出现的位置,若指定了 m 则是查找第 m 次出现的位置</p></blockquote><p> <code>SELECT INSTR(&#39;thinking in java&#39;,&#39;in&#39;,4,2) FROM dual</code></p></li></ul><hr><h3 id="数值函数"><a href="#数值函数" class="headerlink" title="数值函数"></a>数值函数</h3><ul><li><p><strong>ROUND(n [,m])</strong></p><blockquote><p>对 n 进行四舍五入, m 是保留到小数点后多少位, 若 m 为 0 或不指定,则保留整数,若 m 为负数, 则是保留小数点前的位数</p></blockquote><p>  <code>SELECT ROUND(45.678 , 2), ROUND(45.678) FROM dual</code><br><code>SELECT ROUND(45.678 , -1), ROUND(55.678, -2),ROUND(45.76, -2) FROM dual</code></p></li><li><p><strong>TRUNC(n,[,m])</strong></p><blockquote><p>数字截取函数,对 n 截取 m 位</p></blockquote><p>  <code>SELECT TRUNC(45.678, 2), TRUNC(45.678), TRUNC(55.678, -1) FROM dual</code></p></li><li><p><strong>MOD(n, m)</strong></p><blockquote><p>求余数,若 m 为 0 ,则直接返回 n</p></blockquote><p>  <code>SELECT MOD(13,4) FROM dual</code></p></li><li><p><strong>CEIL(n)和 FLOOR(n)</strong></p><blockquote><p>向上取整,向下取整</p></blockquote><p>  <code>SELECT CEIL(45.67) , FLOOR(45.67) FROM dual</code></p></li></ul><hr><h3 id="日期类型"><a href="#日期类型" class="headerlink" title="日期类型"></a>日期类型</h3><ul><li><p><strong>DATE 与 TIMESTAMP</strong></p><blockquote><p>两者都是常用的日期类型, DATE 为7个字节,TIMESTAMP 为11个字节,多出来的4个字节用来表示秒以下的精度</p></blockquote></li><li><p>日期相关关键字</p><blockquote><p><strong>SYSDATE</strong> : 表示一个内部函数,返回一个表示当前系统时间的 DATE  类型的值<br><strong>SYSTIMESTAMP</strong> : 返回时间戳类型的当前系统时间</p></blockquote></li><li><p>日期类型比较大小</p><blockquote><p>越晚的越大,日期可以进行加减运算,加上一个数字等于加上指定的天数,减法同理.<br>两个日期相减,差为相差的天数</p></blockquote><ul><li>查看每个员工入职天数(取整)<br><code>SELECT ename, CEIL(SYSDATE-hiredate) FROM emp</code></li><li>查看 1982-1-1 以后入职的员工<br><code>SELECT ename, hiredate FROM empWHERE hiredate &gt; TO_DATE(&#39;1982-01-01&#39;,&#39;YYYY-MM-DD&#39;);</code></li></ul></li></ul><ul><li><p><strong>TO_DATE()</strong></p><blockquote><p>可以将一个字符串按照指定的日期格式转换成DATE</p></blockquote><p>RR : 两位数字表示年,会自动判定世纪<br>1950-02-04<br><code>SELECT TO_CHAR(TO_DATE(&#39;50-02-04&#39;,&#39;RR-MM-DD&#39;),&#39;YYYY-MM-DD&#39;) FROM dual</code><br>2049-02-04<br><code>SELECT TO_CHAR(TO_DATE(&#39;49-02-04&#39;,&#39;RR-MM-DD&#39;),&#39;YYYY-MM-DD&#39;) FROM dual</code></p></li><li><p><strong>TO_CHAR()</strong></p><blockquote><p>可以将日期按照指定日期格式转换为字符串<br><code>SELECT TO_CHAR(SYSDATE,&#39;YYYY-MM-DD HH12:MI:SS&#39;) FROM dual</code></p></blockquote><p>  注意: 日期格式字符串中,出现的字符凡是不是英文与符号,其他字符全部要使用双引号包围<br><code>SELECT TO_CHAR(SYSDATE,&#39;YYYY&quot;年&quot;MM&quot;月&quot;DD&quot;日&quot;&#39;) FROM dual</code></p></li><li><p><strong>LAST_DAY(date)</strong></p><blockquote><p>返回给定日期所在月的月底日期</p></blockquote><p>  <code>SELECT LAST_DAY(SYSDATE) FROM dual</code></p></li><li><p><strong>ADD_MONTHS(date , i)</strong></p><blockquote><p>返回日期date 加上 i 个月后的日期值</p></blockquote><pre><code>查看每个员工入职20周年纪念日</code></pre><p><code>SELECT ename, ADD_MONTHS(hiredate,20*12) FROM emp</code></p></li><li><p><strong>MONTHS_BETWEEN (date1, date2)</strong></p><blockquote><p>查看两个日期之间相差多少月</p></blockquote><p>  每个职工入职多少个月<br><code>SELECT ename, MONTHS_BETWEEN(SYSDATE, hiredate) FROM emp</code>  </p></li><li><p><strong>NEXT_DAY(date , i)</strong></p><blockquote><p>返回给定日期之后一周内的周几对应的日期</p></blockquote><p>  <code>SELECT NEXT_DAY(SYSDATE,4) FROM dual</code></p></li><li><p><strong>LEAST,GREATEST</strong>  </p><blockquote><p>返回参数列表中 最小值 和 最大值</p></blockquote><p>  <code>SELECT LEAST(SYSDATE, TO_DATE(&#39;2008-08-08&#39;,&#39;YYYY-MM-DD&#39;)) FROM dual</code></p><p>82 年以前返回1982-1-1, 82年以后返回入职日期<br><code>SELECT ename, GREATEST(hiredate, TO_DATE(&#39;1982-01-01&#39;,&#39;YYYY-MM-DD&#39;)) FROM emp</code></p></li><li><p><strong>EXTRACT</strong></p><blockquote><p>提取一个日期中指定的时间分量</p></blockquote><p>  <code>SELECT EXTRACT(YEAR FROM SYSDATE) FROM dual</code><br>查看1982年入职的员工<br><code>SELECT ename, hiredate FROM emp WHERE EXTRACT(YEAR FROM hiredate )=1982</code></p></li></ul><h3 id="NULL"><a href="#NULL" class="headerlink" title="NULL"></a>NULL</h3><ul><li><p>NULL 的运算</p><ul><li>与字符串连接等于什么也没做</li><li>与数字运算结果还是 NULL</li></ul></li><li><p><strong>NVL(p1, p2)</strong></p><blockquote><p>当 p1 为 NULL 时,函数返回 p2, 若 p1 不为 NULL ,则函数返回 p1 本身</p></blockquote><p><code>SELECT ename ,sal, comm,sal+NVL(comm, 0 ) FROM emp</code></p></li><li><p><strong>NVL2(p1, p2 , p3)</strong></p><blockquote><p>若 p1 为 NULL 则返回 p3, 若 p1 不为 NULL 则返回 p2<br>根据com字段是否为 NULL 判断有没有奖金</p></blockquote><p>  <code>SELECT ename, NVL2(comm,&#39;有奖金&#39;,&#39;没奖金&#39;) FROM emp</code></p></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Oracle-数据库&quot;&gt;&lt;a href=&quot;#Oracle-数据库&quot; class=&quot;headerlink&quot; title=&quot;Oracle 数据库&quot;&gt;&lt;/a&gt;Oracle 数据库&lt;/h2&gt;&lt;h3 id=&quot;修改表&quot;&gt;&lt;a href=&quot;#修改表&quot; class=&quot;header
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>Oracle 学习笔记02</title>
    <link href="http://yoursite.com/2018/03/20/oracle%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B002/"/>
    <id>http://yoursite.com/2018/03/20/oracle学习笔记02/</id>
    <published>2018-03-20T05:06:48.000Z</published>
    <updated>2018-03-29T08:05:21.768Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Oracle-数据库-SQL基础查询"><a href="#Oracle-数据库-SQL基础查询" class="headerlink" title="Oracle 数据库( SQL基础查询)"></a>Oracle 数据库( SQL基础查询)</h2><h3 id="1-基本查询语句"><a href="#1-基本查询语句" class="headerlink" title="1. 基本查询语句"></a>1. 基本查询语句</h3><ul><li><p><strong>使用别名</strong></p><blockquote><p>当一个SELECT 子句中查询的内容是一个函数或者表达式, 那么在结果集中对应的该字段的字段名就是这个函数表达式,可读性差,为此应当为该列添加别名</p></blockquote><p><code>SELECT ename , sal*12 salary  FROM emp</code><br>或<br><code>SELECT ename , sal*12 AS salary  FROM emp</code><br>别名不区分 大小写,若希望区分大小写,或者别名中含有空格,可以使用双引号包围<br><code>SELECT ename , sal*12 &quot;sa A lary&quot;  FROM emp;</code></p></li></ul><hr><h3 id="2-查询条件"><a href="#2-查询条件" class="headerlink" title="2. 查询条件"></a>2. 查询条件</h3><ul><li><p><strong>使用 &lt; , &gt; , &lt;&gt;(不等于)</strong><br><code>SELECT ename, sal FROM emp WHERE sal&lt; 2000</code></p><p><code>SELECT ename,sal,job FROM emp WHERE deptno &lt;&gt; 10;</code></p><p><code>SELECT ename,sal,hiredate FROM empWHERE　hiredate &gt;TO_DATE(&#39;1982-01-01&#39;,&#39;YYYY_MM_DD&#39;)</code></p></li><li><p><strong>AND, OR 关键字</strong><br><code>SELECT ename, sal, job FROM empWHERE sal &gt; 1000 AND job=&#39;CLERK&#39;</code></p><p><code>SELECT ename, sal, job FROM empWHERE sal &gt; 1000 OR job=&#39;CLERK&#39;</code></p><blockquote><p>AND 的优先级高于 OR 所以,可以通过添加括号来提高<br>OR的优先级</p></blockquote><p> <code>SELECT ename, sal, job FROM empWHERE sal &gt; 1000 AND (job=&#39;SALESMAN&#39; OR job=&#39;CLERK&#39;)</code></p></li><li><p><strong>LIKE 条件</strong></p><blockquote><p>LIKE 用于模糊匹配字符串,它需要借助两个通配符:<br> <strong>%</strong> : 表示 0 到 多个字符<br> <strong>_</strong> : 表示单个字符</p></blockquote><p> 查看员工第二个字符是 A 的员工:<br> <code>SELECT ename, job, sal FROM emp  WHERE ename LIKE &#39;_A%&#39;</code></p></li><li><p><strong>IN (List) , NOT IN (List)</strong></p><blockquote><p>判断在列表中,不在列表中,常用于子查询中</p></blockquote><p> <code>SELECT ename, job, sal FROM empWHERE job IN (&#39;MANAGER&#39;,&#39;CLERK&#39;)</code></p></li><li><p><strong>BETWEEN…AND…</strong></p><blockquote><p>查询符合某个值域范围的数据</p></blockquote><p> <code>SELECT ename,sal FROM empWHERE sal BETWEEN 1500 AND　3000</code></p></li><li><p><strong>使用 ANY 和 ALL 条件</strong></p><blockquote><p>用于判断诸如 : &gt; , &gt;= , &lt; , &lt;= 一个列表的内容<br>&gt;ALL(list) : 大于列表中所有的 ( 大于最大的)<br>&gt;ANY(list) : 大于列表中之一即可 ( 大于最小的)</p></blockquote><p> 以下查询结果相同:<br><code>SELECT empno, ename, job, sal, deptno FROM emp WHERE sal &gt; ALL(1500,2500,2000)</code><br><code>SELECT empno, ename, job, sal, deptno FROM emp WHERE sal &gt; ANY(2500,4500,4000)</code></p><blockquote><p>ANY 和 ALL 的列表通常不会给特定的值,这样没有意义,通常使用在判断一个子查询的结果</p></blockquote></li><li><p><strong>查询条件中使用表达式和函数</strong><br><code>SELECT ename, sal, job FROM emp WHERE ename = UPPER(&#39;scott&#39;)</code><br><code>SELECT ename, sal, job FROM emp WHERE sal*12&gt;50000</code></p></li><li><p><strong>DISTINCT 过滤重复</strong></p><blockquote><p>去除后面指定字段的重复行,<strong>必须紧跟在 SELECT 关键字之后</strong></p></blockquote><p> 查看员工职位种类数<br><code>SELECT DISTINCT　job FROM emp</code><br>DISTINCT 后面可以跟多个字段: 这些字段值的组合没有重复<br>以下查询不会出现 同一部门相同职位 的人<br><code>SELECT DISTINCT　job, deptno FROM emp</code></p></li></ul><hr><h3 id="3-排序"><a href="#3-排序" class="headerlink" title="3. 排序"></a>3. 排序</h3><ul><li><p><strong>ORDER BY 排序</strong></p><blockquote><p>可以根据后面指定的字段对结果集进行升序或降序排列,其中 ASC 是升序, DESC 是降序,通常不写 ASC ,默认升序</p></blockquote><p><strong>ORDER BY 子句只能存在 SELECT 语句中最后一个子句上</strong><br><code>SELECT ename, sal FROM emp ORDER BY sal</code></p><blockquote><p>ORDER BY 可以按照多个字段排序,排序是有优先级的,首先按照第一个字段的排序规则偶像,当第一个字段有重复值时,才按照第二个字段排序</p></blockquote><p>  <code>SELECT ename, deptno, sal FROM emp ORDER BY deptno, sal DESC</code></p></li></ul><hr><h3 id="4-聚合函数"><a href="#4-聚合函数" class="headerlink" title="4. 聚合函数"></a>4. 聚合函数</h3><blockquote><p>聚合函数又称为多行函数,分组函数,聚合函数可以将多条记录进行统计,然后得出一个结果.所以聚合函数是用来统计使用的</p></blockquote><ul><li><p><strong>MAX() 和 MIN ()</strong> : 统计最大值和最小值<br>查看公司的最高工资是多少<br><code>SELECT MAX(sal) FROM emp</code></p></li><li><p><strong>AVG() 和 SUM()</strong> : 求平均值,总和<br><code>SELECT AVG(sal) FROM emp</code><br><code>SELECT SUM(sal) FROM emp</code></p></li><li><p><strong>COUNT()</strong> : 统计记录总数<br><code>SELECT COUNT(ename) FROM emp</code></p></li></ul><blockquote><p><strong>注意</strong>: 聚合函数忽略 NULL 值<br>举例: <code>SELECT AVG(comm) FROM emp</code><br>上述查询,如果comm字段存在 NULL 值则除数不符合实际值,结果不正确<br>解决: <code>SELECT AVG(NVL(comm,0)) FROM emp</code></p></blockquote><hr><h3 id="5-分组"><a href="#5-分组" class="headerlink" title="5. 分组"></a>5. 分组</h3><ul><li><p><strong>GROUP BY 子句</strong></p><blockquote><p>可以将结果集按照指定的字段值相同的记录看做是一组,配合聚合函数使用可以对不同分组的记录分别进行统计然后得到结果</p></blockquote><p>查看每个部门最高工资和最低工资<br><code>SELECT MAX(sal) , MIN(sal) FROM emp GROUP BY deptno</code></p><blockquote><p>在 SELECT 当中若使用了聚合函数,那么不在聚合函数中的其他单独字段必须出现在 GROUP BY 子句中,反过来不是必须的<br>GROUP BY 也可以按照多个字段进行分组,分组原则是这些字段值的组合相同的看做一组</p></blockquote><p>  查看每个部门每种职位的平均工资<br><code>SELECT AVG(sal), deptno||job FROM emp GROUP BY deptno, job</code>  </p><blockquote><p>WHERE 的过滤时机: WHERE 是在查询表中每一条数据是进行过滤的,只会将满足 WHERE 条件的记录查询出来 ,所以聚合函数无法使用在 WHERE 后, 解决的该问题可以用 HAVING 子句</p></blockquote></li><li><p><strong>HAVING 子句</strong></p><blockquote><p>HAVING 子句必须紧跟在GROUP BY 子句之后,作用是添加条件来过滤不同的分组, HAVING 可以用聚合函数作为过滤条件</p></blockquote><p>查看平均工资高于2000的部门 的平均工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(sal) <span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">AVG</span>(sal)&gt;<span class="number">2000</span></span><br></pre></td></tr></table></figure><p>查看平均工资高于2000 的部门的最高和最低工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">MAX</span>(sal) , <span class="keyword">MIN</span>(sal), deptno  <span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> deptno</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">AVG</span>(sal)&gt;<span class="number">2000</span></span><br></pre></td></tr></table></figure><p>查看最高工资&gt;=3000 的职位的平均工资</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> <span class="keyword">AVG</span>(sal) , job <span class="keyword">FROM</span> emp</span><br><span class="line"><span class="keyword">GROUP</span> <span class="keyword">BY</span> job</span><br><span class="line"><span class="keyword">HAVING</span> <span class="keyword">MAX</span>(sal)&gt;=<span class="number">3000</span></span><br></pre></td></tr></table></figure></li></ul><hr><h3 id="SQL-关联查询"><a href="#SQL-关联查询" class="headerlink" title="SQL 关联查询"></a>SQL 关联查询</h3><blockquote><ul><li>关联查询时间建立在多张上进行联合查询</li><li>查询的结果集中,每一条记录中的字段可能来自不同的表</li><li>重点: 找到表与表的记录之间的对应关系</li></ul></blockquote><p>查询每个员工的基本信息及其部门信息<br><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.ename, e.job, e.sal , d.dname, d.loc, d.deptno</span><br><span class="line"><span class="keyword">FROM</span> emp e, dept d</span><br><span class="line"><span class="keyword">WHERE</span> e.deptno = d.deptno</span><br></pre></td></tr></table></figure></p><ul><li><p>上述 SQL 中: e.deptno = d.deptno 条件是用来联系 emp 和 dept 的数据关系的,这样的条件称为连接条件</p></li><li><p>在关联查询中,必须要添加连接条件,N 张表关联查询至少要添加 N-1 连接条件.不添加连接条件,会产生笛卡尔积 ( 实际开发要避免 )</p></li><li><p>关联查询的连接条件与过滤条件要同时成立</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.ename , e.job, e.sal, e.deptno,d.dname</span><br><span class="line"><span class="keyword">FROM</span> emp e, dept d</span><br><span class="line"><span class="keyword">WHERE</span> e.deptno = d.deptno</span><br><span class="line"><span class="keyword">AND</span> d.dname=<span class="string">'SALES'</span></span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>内连接</strong><br>关联查询的另一种写法</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.ename, d.dname</span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">JOIN</span> dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno= d.deptno</span><br></pre></td></tr></table></figure><p>这样写的好处是 过滤条件和连接条件分开 ,结构更明确</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> e.ename, d.dname</span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">JOIN</span> dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno= d.deptno</span><br></pre></td></tr></table></figure></li></ul><hr><ul><li><p><strong>外连接</strong></p><blockquote><p>内连接返回满足连接条件的数据记录,而如果需要将不满足连接条件的记录返回,则需要使用外连接</p></blockquote></li><li><p><strong>左外连接</strong>:</p><blockquote><p>以 JOIN 左侧的表为驱动表,该表所有记录都要显示出来,那么当某条记录不满足连接条件时,来自 JOIN 右侧表中的字段的值全部为 NULL</p></blockquote><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.ename,e.sal, d.dname ,d.loc</span><br><span class="line"><span class="keyword">FROM</span> emp e <span class="keyword">LEFT</span> <span class="keyword">OUTER</span> <span class="keyword">JOIN</span> dept d</span><br><span class="line"><span class="keyword">ON</span> e.deptno= d.deptno</span><br></pre></td></tr></table></figure></li><li><p><strong>右外连接</strong> : 以 JOIN 右侧的表为驱动表,其他特性同上<br><code>RIGTH OUTER JOIN ...ON...</code></p></li><li><p><strong>全外连接</strong> : JOIN 两侧的表都为驱动表,综合左右外连接内容<br><code>FULL OUTER JOIN...ON...</code></p></li><li><p><strong>一般关联查询实现外连接效果</strong>: (+) 定义在连接条件上,定义在哪边哪边就补 NULL 但是无法实现全外连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">SELECT</span> e.ename, d.dname <span class="keyword">FROM</span> emp e, dept d</span><br><span class="line"> <span class="keyword">WHERE</span> e.deptno(+) = d.deptno</span><br><span class="line"> <span class="string">``</span><span class="string">`  </span></span><br><span class="line"><span class="string">- **自连接**</span></span><br><span class="line"><span class="string">&gt;当前表的一条记录对应当前表本身的多条记录, 这种设计就是自连接,自连接是用来解决数据内容相同,但是数据间又存在上下级关系的树状结构情况</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string"> 查找每个员工及其上司的名字</span></span><br><span class="line"><span class="string"> `</span><span class="string">``</span><span class="keyword">SQL</span></span><br><span class="line"> <span class="keyword">SELECT</span> e.ename worker, m.ename manager <span class="keyword">FROM</span> emp e,emp m</span><br><span class="line"> <span class="keyword">WHERE</span> e.mgr = m.empno</span><br></pre></td></tr></table></figure><p>上述结果采用内连接</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">SELECT</span> e.ename worker, m.ename manager <span class="keyword">FROM</span> emp e <span class="keyword">JOIN</span> emp m</span><br><span class="line"><span class="keyword">ON</span> e.mgr = m.empno</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;Oracle-数据库-SQL基础查询&quot;&gt;&lt;a href=&quot;#Oracle-数据库-SQL基础查询&quot; class=&quot;headerlink&quot; title=&quot;Oracle 数据库( SQL基础查询)&quot;&gt;&lt;/a&gt;Oracle 数据库( SQL基础查询)&lt;/h2&gt;&lt;h3 i
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="数据库" scheme="http://yoursite.com/tags/%E6%95%B0%E6%8D%AE%E5%BA%93/"/>
    
  </entry>
  
  <entry>
    <title>基于 Hexo + GitHub Pages 搭建个人博客</title>
    <link href="http://yoursite.com/2017/11/30/%E5%9F%BA%E4%BA%8E-Hexo-GitHub-Pages-%E6%90%AD%E5%BB%BA%E4%B8%AA%E4%BA%BA%E5%8D%9A%E5%AE%A2/"/>
    <id>http://yoursite.com/2017/11/30/基于-Hexo-GitHub-Pages-搭建个人博客/</id>
    <published>2017-11-29T16:06:48.000Z</published>
    <updated>2017-11-30T16:30:11.633Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>之前一直想弄个自己的个人博客，记录自己的学习历程。看了很多网站，像 CSDN 、博客园 、简书也都有博客专栏，总感觉不够个性化，但自己撸一个网站苦于前端技术太渣，耗时好力还不讨喜。于是折中选择使用 Hexo + GitHub 来搭建这个个人博客，也顺便熟悉一下 git 的基本知识。</p><hr><h1 id="什么是-Hexo"><a href="#什么是-Hexo" class="headerlink" title="什么是 Hexo"></a>什么是 Hexo</h1><blockquote><p>Hexo 是一款基于 Node.js 的静态博客框架，可以生成静态网页托管在 GitHub 和 Heroku 上。Hexo 使用 Markdown （或其他渲染引擎）解析文章，在几秒内即可利用靓丽的主题生成静态网页（简直是前端小白福音啊）</p></blockquote><p><a href="https://hexo.io/zh-cn/" target="_blank" rel="noopener">Hexo 官网</a></p><hr><h1 id="如何使用-Hexo"><a href="#如何使用-Hexo" class="headerlink" title="如何使用 Hexo"></a>如何使用 Hexo</h1><p>前面说了 Hexo 是基于 Node.js 的，所以需要系统中安装 Node.js。因为博客是托管在 GitHub 上的，所以还要安装 git</p><ol><li><p>安装 Node.js<br><a href="https://nodejs.org/download/" target="_blank" rel="noopener">下载 Node.js</a><br><a href="http://www.runoob.com/nodejs/nodejs-install-setup.html" target="_blank" rel="noopener">安装教程</a></p></li><li><p>安装 git （按照默认设置的安装就好）<br><a href="https://git-scm.com/download/" target="_blank" rel="noopener">下载 git</a><br>对于 git 或者 不了解 GitHub 的同学点击 <a href="http://stormzhang.com/github/2016/05/25/learn-github-from-zero1/" target="_blank" rel="noopener">stormzhang的博客</a>，本文不扩展这部分内容了</p></li><li><p>安装 Hexo<br>新建一个文件夹命名为 Hexo，在该文件夹下右键鼠标选择 Git Bash Here<br>依次输入一下命令（安装无进度提示，过程需要等待）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cd d:/hexo</span><br><span class="line">$ npm install hexo-cli -g</span><br><span class="line">$ hexo init blog # 创建 blog 文件夹</span><br><span class="line">$ cd blog</span><br><span class="line">$ npm install</span><br><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure></li></ol><p>完成以上操作，显示本地的 web 服务器已经启动了，在浏览器中输入 <a href="localhost:4000" target="_blank" rel="noopener">localhost:4000</a> 即可看到默认生成的博客页面了（已经有一篇默认的博文）<br>常用命令：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new &quot;Name&quot; # 创建一篇 blog</span><br><span class="line">$ hexo generate # （简写 hexo g） 生成网站</span><br><span class="line">$ hexo server # （简写 hexo s） 启动本地服务器</span><br><span class="line">$ hexo deploy # （简写 hexo d）</span><br><span class="line">$ hexo clean # 清除缓存文件 （db.json） 和已经生成的静态文件（public文件夹）</span><br></pre></td></tr></table></figure></p><p><a href="https://hexo.io/zh-cn/docs/commands.html" target="_blank" rel="noopener">更多 Hexo 命令</a></p><hr><h1 id="如何写博客"><a href="#如何写博客" class="headerlink" title="如何写博客"></a>如何写博客</h1><p>通过命令创建一篇博客后，打开 blog 文件夹，该篇博文在 source 文件夹的 <code>_posts</code> 子文件夹下，使用 markdown 编辑器（自行搜索下载）打开该文件即可编辑内容。删除该文件并重新生成网页后该博客就可被删除。<br><a href="https://sspai.com/post/25137" target="_blank" rel="noopener">了解更多 Markdown 相关内容</a></p><hr><h1 id="如何修改页面上的内容"><a href="#如何修改页面上的内容" class="headerlink" title="如何修改页面上的内容"></a>如何修改页面上的内容</h1><p>所有可供修改的内容均在 <code>_config.yml</code> 配置文件当中，自行修改对应内容的参数和数据即可。<br>如果你使用了 GitHub 上的不同主题，则需要修改对应主题文件包下的 <code>_config.yml</code> 配置文件</p><hr><h1 id="部署到-GitHub-Pages"><a href="#部署到-GitHub-Pages" class="headerlink" title="部署到 GitHub Pages"></a>部署到 GitHub Pages</h1><p>不了解 GitHub 的同学在前面安装 git 的时候应该已经初步了解并注册了 GitHub 账号了吧。那么就进行以下步骤：</p><ol><li><p><strong>部署准备(授权本机向 GitHub 提交代码)</strong><br>向 GitHub 提交代码是需要授权的，不能随意提交，GitHub 上一般是基于 SSH 授权的。SSH 是一种网络协议，用于计算机之间的加密登录。<br>Linux 和 Mac 是默认安装了 SSH，Windows系统在安装了 git 之后也是自带 SSH 的。（在 Git Bash 里输入 ssh 出现以下提示说明本机已安装）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/ssh.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><ul><li>继续输入命令 <code>ssh-keygen -t rsa</code>（指定 rsa 算法生成密钥，接着连续三个回车）系统就会生成 id_rsa 和 id_rsa.pub 两个文件（Windows 在c:/Documents and Settings/username/.ssh 下）。前者为本机密钥，后者为公钥，两者配对才能授权成功。</li><li>记事本打开 id_rsa.pub 文件，复制内容</li><li>在 GitHub 上添加 SSH key 公钥, 点击你的 GitHub 头像，选择 Settings，添加 SSH<br><img src="/images/ssh2.png" alt=""><br>在红色框内粘贴复制的内容，title可不填<br><img src="/images/ssh3.png" alt=""></li><li>验证是否添加成功<br><img src="/images/ssh4.png" alt=""></li></ul></li><li><p><strong>在 GitHub 上创建一个新的 repository</strong></p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/1.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/2.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure><p>PS：repository命名以<code>.github.io</code>结尾时，会自动开启 GitHub Pages 如下图（在仓库的Settings 选项中）</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/3.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li><p><strong>将本地 Hexo 页面部署到 GitHub Pages</strong></p><ul><li><p>步骤一：修改配置文件，找到 <code>_config.yml</code> 文件中的 deploy 部分（用 sublime 等编辑器打开，保证保存的编码为 UTF-8 ）作如下修改（注意冒号后面要有空格）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repo: git@github.com:username/username.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure></li><li><p>步骤二：安装用于发布的扩展插件（在 blog 目录下）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure></li><li><p>步骤三：执行命令 <code>$ hexo d</code></p></li></ul></li></ol><blockquote><p>部署原理：</p><ol><li>之前步骤中在 GitHub 上创建的那个 repo（username.github.io）一个最大的特点就是其 master 中的 html 静态文件，可以通过链接<code>http://username.github.io</code>来直接访问。</li><li>hexo g 会生成一个静态网站（第一次会生成一个 public 目录），这个静态文件可以直接访问。</li><li>需要将 hexo 生成的静态网站，提交 (git commit) 到 GitHub 上。</li></ol></blockquote><p>接下来访问你的博客网址，会发现已经变成了之前 Hexo 生成的页面了。<br>简单的博客网站已经搭建完成了，当然，完成以上步骤只是使用了原始 Hexo 框架提供的主题。GitHub上还有很多基于 Hexo的酷炫主题可供修改博客页面。</p><h1 id="Hexo-主题配置"><a href="#Hexo-主题配置" class="headerlink" title="Hexo 主题配置"></a>Hexo 主题配置</h1><p>以我当前主题（indigo）为例。</p><ol><li><p>在 GitHub 上搜索 hexo theme，找到 indigo</p><figure class="image-bubble">                <div class="img-lightbox">                    <div class="overlay"></div>                    <img src="/images/indigo.png" alt="" title="">                </div>                <div class="image-caption"></div>            </figure></li><li><p>在 blog 文件夹下执行以下命令将项目 clone 到本地，这时候 themes 文件夹下会出现该项目文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo</span><br></pre></td></tr></table></figure><p>PS：由于该主题对应环境有要求（node 6.0+，Hexo 3.0+），并且需要一些环境依赖，安装相应插件。具体参考该主题提供的<a href="https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">文档</a></p></li><li>打开 blog 文件夹中的 <code>_config.yml</code> 配置文件，找到 theme 选项，修改为 indigo (项目文件名)</li><li>修改主题文件的<code>_config.yml</code> 配置文件，具体修改同样参考<a href="https://github.com/yscoder/hexo-theme-indigo/wiki/%E5%AE%89%E8%A3%85" target="_blank" rel="noopener">文档</a></li><li>重新生成 Hexo 网页并部署到 GitHub Pages上。</li></ol><p>至此，博客网站已搭建完成，更多内容修改和功能配置参考主题文档即可。<br>本人非常喜欢这个主题，非常感谢主题开发者：<a href="https://github.com/yscoder" target="_blank" rel="noopener">https://github.com/yscoder</a> ，必须给 star 呀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h1&gt;&lt;p&gt;之前一直想弄个自己的个人博客，记录自己的学习历程。看了很多网站，像 CSDN 、博客园 、简书也都有博客专栏，总感觉不够个性化，但自己撸一个
      
    
    </summary>
    
      <category term="技术" scheme="http://yoursite.com/categories/%E6%8A%80%E6%9C%AF/"/>
    
    
      <category term="Hexo" scheme="http://yoursite.com/tags/Hexo/"/>
    
      <category term="GitHub" scheme="http://yoursite.com/tags/GitHub/"/>
    
  </entry>
  
</feed>
