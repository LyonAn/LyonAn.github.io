[{"title":"Oracle 学习笔记02","date":"2018-03-20T05:06:48.000Z","path":"2018/03/20/oracle学习笔记02/","text":"Oracle 数据库( SQL基础查询)1. 基本查询语句 使用别名 当一个SELECT 子句中查询的内容是一个函数或者表达式, 那么在结果集中对应的该字段的字段名就是这个函数表达式,可读性差,为此应当为该列添加别名 SELECT ename , sal*12 salary FROM emp或SELECT ename , sal*12 AS salary FROM emp别名不区分 大小写,若希望区分大小写,或者别名中含有空格,可以使用双引号包围SELECT ename , sal*12 &quot;sa A lary&quot; FROM emp; 2. 查询条件 使用 &lt; , &gt; , &lt;&gt;(不等于)SELECT ename, sal FROM emp WHERE sal&lt; 2000 SELECT ename,sal,job FROM emp WHERE deptno &lt;&gt; 10; SELECT ename,sal,hiredate FROM emp WHERE hiredate &gt;TO_DATE(&#39;1982-01-01&#39;,&#39;YYYY_MM_DD&#39;) AND, OR 关键字SELECT ename, sal, job FROM emp WHERE sal &gt; 1000 AND job=&#39;CLERK&#39; SELECT ename, sal, job FROM emp WHERE sal &gt; 1000 OR job=&#39;CLERK&#39; AND 的优先级高于 OR 所以,可以通过添加括号来提高OR的优先级 SELECT ename, sal, job FROM emp WHERE sal &gt; 1000 AND (job=&#39;SALESMAN&#39; OR job=&#39;CLERK&#39;) LIKE 条件 LIKE 用于模糊匹配字符串,它需要借助两个通配符: % : 表示 0 到 多个字符 _ : 表示单个字符 查看员工第二个字符是 A 的员工: SELECT ename, job, sal FROM emp WHERE ename LIKE &#39;_A%&#39; IN (List) , NOT IN (List) 判断在列表中,不在列表中,常用于子查询中 SELECT ename, job, sal FROM emp WHERE job IN (&#39;MANAGER&#39;,&#39;CLERK&#39;) BETWEEN…AND… 查询符合某个值域范围的数据 SELECT ename,sal FROM emp WHERE sal BETWEEN 1500 AND 3000 使用 ANY 和 ALL 条件 用于判断诸如 : &gt; , &gt;= , &lt; , &lt;= 一个列表的内容&gt;ALL(list) : 大于列表中所有的 ( 大于最大的)&gt;ANY(list) : 大于列表中之一即可 ( 大于最小的) 以下查询结果相同:SELECT empno, ename, job, sal, deptno FROM emp WHERE sal &gt; ALL(1500,2500,2000)SELECT empno, ename, job, sal, deptno FROM emp WHERE sal &gt; ANY(2500,4500,4000) ANY 和 ALL 的列表通常不会给特定的值,这样没有意义,通常使用在判断一个子查询的结果 查询条件中使用表达式和函数SELECT ename, sal, job FROM emp WHERE ename = UPPER(&#39;scott&#39;)SELECT ename, sal, job FROM emp WHERE sal*12&gt;50000 DISTINCT 过滤重复 去除后面指定字段的重复行,必须紧跟在 SELECT 关键字之后 查看员工职位种类数SELECT DISTINCT job FROM empDISTINCT 后面可以跟多个字段: 这些字段值的组合没有重复以下查询不会出现 同一部门相同职位 的人SELECT DISTINCT job, deptno FROM emp 3. 排序 ORDER BY 排序 可以根据后面指定的字段对结果集进行升序或降序排列,其中 ASC 是升序, DESC 是降序,通常不写 ASC ,默认升序 ORDER BY 子句只能存在 SELECT 语句中最后一个子句上SELECT ename, sal FROM emp ORDER BY sal ORDER BY 可以按照多个字段排序,排序是有优先级的,首先按照第一个字段的排序规则偶像,当第一个字段有重复值时,才按照第二个字段排序 SELECT ename, deptno, sal FROM emp ORDER BY deptno, sal DESC 4. 聚合函数 聚合函数又称为多行函数,分组函数,聚合函数可以将多条记录进行统计,然后得出一个结果.所以聚合函数是用来统计使用的 MAX() 和 MIN () : 统计最大值和最小值查看公司的最高工资是多少SELECT MAX(sal) FROM emp AVG() 和 SUM() : 求平均值,总和SELECT AVG(sal) FROM empSELECT SUM(sal) FROM emp COUNT() : 统计记录总数SELECT COUNT(ename) FROM emp 注意: 聚合函数忽略 NULL 值举例: SELECT AVG(comm) FROM emp上述查询,如果comm字段存在 NULL 值则除数不符合实际值,结果不正确解决: SELECT AVG(NVL(comm,0)) FROM emp 5. 分组 GROUP BY 子句 可以将结果集按照指定的字段值相同的记录看做是一组,配合聚合函数使用可以对不同分组的记录分别进行统计然后得到结果 查看每个部门最高工资和最低工资SELECT MAX(sal) , MIN(sal) FROM emp GROUP BY deptno 在 SELECT 当中若使用了聚合函数,那么不在聚合函数中的其他单独字段必须出现在 GROUP BY 子句中,反过来不是必须的GROUP BY 也可以按照多个字段进行分组,分组原则是这些字段值的组合相同的看做一组 查看每个部门每种职位的平均工资SELECT AVG(sal), deptno||job FROM emp GROUP BY deptno, job WHERE 的过滤时机: WHERE 是在查询表中每一条数据是进行过滤的,只会将满足 WHERE 条件的记录查询出来 ,所以聚合函数无法使用在 WHERE 后, 解决的该问题可以用 HAVING 子句 HAVING 子句 HAVING 子句必须紧跟在GROUP BY 子句之后,作用是添加条件来过滤不同的分组, HAVING 可以用聚合函数作为过滤条件查看平均工资高于2000的部门 的平均工资 12345SELECT AVG(sal) FROM empGROUP BY deptnoHAVING AVG(sal)&gt;2000 ``` 查看平均工资高于2000 的部门的最高和最低工资 SELECT MAX(sal) , MIN(sal), deptno FROM empGROUP BY deptnoHAVING AVG(sal)&gt;2000 1查看最高工资&gt;=3000 的职位的平均工资 SELECT AVG(sal) , job FROM empGROUP BY jobHAVING MAX(sal)&gt;=3000 12345678---### SQL 关联查询&gt;- 关联查询时间建立在多张上进行联合查询- 查询的结果集中,每一条记录中的字段可能来自不同的表- 重点: 找到表与表的记录之间的对应关系查询每个员工的基本信息及其部门信息 SELECT e.ename, e.job, e.sal , d.dname, d.loc, d.deptnoFROM emp e, dept dWHERE e.deptno = d.deptno12345- 上述 SQL 中: e.deptno = d.deptno 条件是用来联系 emp 和 dept 的数据关系的,这样的条件称为连接条件- 在关联查询中,必须要添加连接条件,N 张表关联查询至少要添加 N-1 连接条件.不添加连接条件,会产生笛卡尔积 ( 实际开发要避免 )- 关联查询的连接条件与过滤条件要同时成立 SELECT e.ename , e.job, e.sal, e.deptno,d.dname FROM emp e, dept d WHERE e.deptno = d.deptno AND d.dname=’SALES’ 1234--- - **内连接** 关联查询的另一种写法 SELECT e.ename, d.dname FROM emp e JOIN dept d ON e.deptno= d.deptno 12这样写的好处是 过滤条件和连接条件分开 ,结构更明确 SELECT e.ename, d.dname FROM emp e JOIN dept d ON e.deptno= d.deptno 1234567--- - **外连接** &gt;内连接返回满足连接条件的数据记录,而如果需要将不满足连接条件的记录返回,则需要使用外连接 - **左外连接**: &gt;以 JOIN 左侧的表为驱动表,该表所有记录都要显示出来,那么当某条记录不满足连接条件时,来自 JOIN 右侧表中的字段的值全部为 NULL SELECT e.ename,e.sal, d.dname ,d.loc FROM emp e LEFT OUTER JOIN dept d ON e.deptno= d.deptno 12345678910111213 - **右外连接** : 以 JOIN 右侧的表为驱动表,其他特性同上 `RIGTH OUTER JOIN ...ON...` - **全外连接** : JOIN 两侧的表都为驱动表,综合左右外连接内容 `FULL OUTER JOIN...ON...` - **一般关联查询实现外连接效果**: (+) 定义在连接条件上,定义在哪边哪边就补 NULL但是无法实现全外连接 SELECT e.ename, d.dname FROM emp e, dept dWHERE e.deptno(+) = d.deptno 12345- **自连接**&gt;当前表的一条记录对应当前表本身的多条记录, 这种设计就是自连接,自连接是用来解决数据内容相同,但是数据间又存在上下级关系的树状结构情况 查找每个员工及其上司的名字 SELECT e.ename worker, m.ename manager FROM emp e,emp mWHERE e.mgr = m.empno 12上述结果采用内连接 SELECT e.ename worker, m.ename manager FROM emp e JOIN emp m ON e.mgr = m.empno ```","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"Oracle 学习笔记01","date":"2018-03-20T05:06:48.000Z","path":"2018/03/20/oracle学习笔记01/","text":"Oracle 数据库修改表 修改表名RENAME old_name TO new_name 修改表结构 添加列为 myemp 添加一列 hiredate :ALTER TABLE myemp ADD (hiredate DATE DEFAULT SYSDATE ) 删除列删除上面添加的字段ALTER TABLE myemp DROP(hiredate) 修改列ALTER TABLE myemp MODIFY(job VARCHAR2(40) DEFAULT &#39;CLERK&#39;) DML 语句 DML 可以对表中的数据进行操作,分为 : INSERT, UPDATE , DELETEDML 是伴随事务 ( Transaction ) 使用的. ####1. INSERTINSERT INTO myemp (id, name, salary, job) VALUES (1, &#39;jack&#39;, 5000, &#39;CLERK&#39; )若不指定字段,则需全列插入INSERT INTO myemp VALUES(...)插入一个日期值INSERT INTO myemp (id, name, salary, birth, job) VALUES (2, &#39;tom&#39;, 3000, TO_DATE(&#39;2008-08-08&#39;,&#39;YYYY-MM-DD&#39;)) 2. UPDATE修改表中现有数据UPDATE myemp SET gender=&#39;F&#39;, salary=9000 WHRER name=&#39;jack&#39; 3. DELETE删除数据通常使用时添加 WHERE 条件,不添加则是清空表 DQL 语句1. SELECT 查看表中所有字段及其记录SELECT * FROM emp查看表中的某几个字段SELECT ename, job, sal FROM empSELECT 子句可以查看:字段,函数,表达式SELECT ename, sal*12 FROM empSELECT 子句结合 WHERE 子句SELECT ename, job,sal,deptno FROM emp WHERE deptno=20 字符串函数 CONCAT(P1,P2) : 字符串拼接SELECT CONCAT(ename, sal) FROM emp; p1 || p2 || p3: 多字符拼接SELECT ename||&#39;:&#39;||sal FROM emp LENGTH (p): 获取字符串长度SELECT ename, LENGTH(ename) FROM emp LOWER, UPPER, INICAP :小写,大写,首字母大写SELECT LOWER(&#39;HELLO WORLD&#39;), UPPER(&#39;helloworld&#39;), INITCAP(&#39;hello world&#39;) FROM dual 伪表 : dual当查询内容与任何一张表无关时,为了满足 FROM子句的要求,可以使用伪表,伪表只会查出一条语句 TRIM , LTRIM, RTRIM:去除字符串两边内容 (注意语法)SELECT TRIM(&#39;e&#39; FROM &#39;eeeeliteeee&#39;) FROM empSELECT LTRIM(&#39;esesesliteeee&#39;,&#39;es&#39;) FROM dualSELECT RTRIM(&#39;eeeeliteeee&#39;,&#39;e&#39;) FROM dual LPAD, RPAD 补位函数,可以将指定内容指定位数,不足时则补充若干个指定的定义字符以达到位数 SELECT LPAD(sal,6,&#39;$&#39;) FROM empSELECT RPAD(sal,6,&#39; &#39;) FROM emp SUBSTR(str,m[,n]) 截取字符串 str 从m处开始,,连续截取n个,若不指定n,则是连续截取到字符串末尾注意:数据库中下标从 1 开始 SELECT SUBSTR(&#39;thinking in java&#39;,10,2) FROM dual INSTR(str1, str2 [,n [,m]]) 查找位置 : 查找 str2 在 str1 中的位置,若指定了位置 n 从 n 处开始查找第一次出现的位置,若指定了 m 则是查找第 m 次出现的位置 SELECT INSTR(&#39;thinking in java&#39;,&#39;in&#39;,4,2) FROM dual 数值函数 ROUND(n [,m]) 对 n 进行四舍五入, m 是保留到小数点后多少位, 若 m 为 0 或不指定,则保留整数,若 m 为负数, 则是保留小数点前的位数 SELECT ROUND(45.678 , 2), ROUND(45.678) FROM dualSELECT ROUND(45.678 , -1), ROUND(55.678, -2),ROUND(45.76, -2) FROM dual TRUNC(n,[,m]) 数字截取函数,对 n 截取 m 位 SELECT TRUNC(45.678, 2), TRUNC(45.678), TRUNC(55.678, -1) FROM dual MOD(n, m) 求余数,若 m 为 0 ,则直接返回 n SELECT MOD(13,4) FROM dual CEIL(n)和 FLOOR(n) 向上取整,向下取整 SELECT CEIL(45.67) , FLOOR(45.67) FROM dual 日期类型 DATE 与 TIMESTAMP 两者都是常用的日期类型, DATE 为7个字节,TIMESTAMP 为11个字节,多出来的4个字节用来表示秒以下的精度 日期相关关键字 SYSDATE : 表示一个内部函数,返回一个表示当前系统时间的 DATE 类型的值SYSTIMESTAMP : 返回时间戳类型的当前系统时间 日期类型比较大小 越晚的越大,日期可以进行加减运算,加上一个数字等于加上指定的天数,减法同理.两个日期相减,差为相差的天数 查看每个员工入职天数(取整)SELECT ename, CEIL(SYSDATE-hiredate) FROM emp 查看 1982-1-1 以后入职的员工SELECT ename, hiredate FROM emp WHERE hiredate &gt; TO_DATE(&#39;1982-01-01&#39;,&#39;YYYY-MM-DD&#39;); TO_DATE() 可以将一个字符串按照指定的日期格式转换成DATE RR : 两位数字表示年,会自动判定世纪1950-02-04SELECT TO_CHAR(TO_DATE(&#39;50-02-04&#39;,&#39;RR-MM-DD&#39;),&#39;YYYY-MM-DD&#39;) FROM dual2049-02-04SELECT TO_CHAR(TO_DATE(&#39;49-02-04&#39;,&#39;RR-MM-DD&#39;),&#39;YYYY-MM-DD&#39;) FROM dual TO_CHAR() 可以将日期按照指定日期格式转换为字符串SELECT TO_CHAR(SYSDATE,&#39;YYYY-MM-DD HH12:MI:SS&#39;) FROM dual 注意: 日期格式字符串中,出现的字符凡是不是英文与符号,其他字符全部要使用双引号包围SELECT TO_CHAR(SYSDATE,&#39;YYYY&quot;年&quot;MM&quot;月&quot;DD&quot;日&quot;&#39;) FROM dual LAST_DAY(date) 返回给定日期所在月的月底日期 SELECT LAST_DAY(SYSDATE) FROM dual ADD_MONTHS(date , i) 返回日期date 加上 i 个月后的日期值 查看每个员工入职20周年纪念日 SELECT ename, ADD_MONTHS(hiredate,20*12) FROM emp MONTHS_BETWEEN (date1, date2) 查看两个日期之间相差多少月 每个职工入职多少个月SELECT ename, MONTHS_BETWEEN(SYSDATE, hiredate) FROM emp NEXT_DAY(date , i) 返回给定日期之后一周内的周几对应的日期 SELECT NEXT_DAY(SYSDATE,4) FROM dual LEAST,GREATEST 返回参数列表中 最小值 和 最大值 SELECT LEAST(SYSDATE, TO_DATE(&#39;2008-08-08&#39;,&#39;YYYY-MM-DD&#39;)) FROM dual 82 年以前返回1982-1-1, 82年以后返回入职日期SELECT ename, GREATEST(hiredate, TO_DATE(&#39;1982-01-01&#39;,&#39;YYYY-MM-DD&#39;)) FROM emp EXTRACT 提取一个日期中指定的时间分量 SELECT EXTRACT(YEAR FROM SYSDATE) FROM dual查看1982年入职的员工SELECT ename, hiredate FROM emp WHERE EXTRACT(YEAR FROM hiredate )=1982 NULL NULL 的运算 与字符串连接等于什么也没做 与数字运算结果还是 NULL NVL(p1, p2) 当 p1 为 NULL 时,函数返回 p2, 若 p1 不为 NULL ,则函数返回 p1 本身 SELECT ename ,sal, comm,sal+NVL(comm, 0 ) FROM emp NVL2(p1, p2 , p3) 若 p1 为 NULL 则返回 p3, 若 p1 不为 NULL 则返回 p2根据com字段是否为 NULL 判断有没有奖金 SELECT ename, NVL2(comm,&#39;有奖金&#39;,&#39;没奖金&#39;) FROM emp","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"基于 Hexo + GitHub Pages 搭建个人博客","date":"2017-11-29T16:06:48.000Z","path":"2017/11/30/基于-Hexo-GitHub-Pages-搭建个人博客/","text":"前言之前一直想弄个自己的个人博客，记录自己的学习历程。看了很多网站，像 CSDN 、博客园 、简书也都有博客专栏，总感觉不够个性化，但自己撸一个网站苦于前端技术太渣，耗时好力还不讨喜。于是折中选择使用 Hexo + GitHub 来搭建这个个人博客，也顺便熟悉一下 git 的基本知识。 什么是 Hexo Hexo 是一款基于 Node.js 的静态博客框架，可以生成静态网页托管在 GitHub 和 Heroku 上。Hexo 使用 Markdown （或其他渲染引擎）解析文章，在几秒内即可利用靓丽的主题生成静态网页（简直是前端小白福音啊） Hexo 官网 如何使用 Hexo前面说了 Hexo 是基于 Node.js 的，所以需要系统中安装 Node.js。因为博客是托管在 GitHub 上的，所以还要安装 git 安装 Node.js下载 Node.js安装教程 安装 git （按照默认设置的安装就好）下载 git对于 git 或者 不了解 GitHub 的同学点击 stormzhang的博客，本文不扩展这部分内容了 安装 Hexo新建一个文件夹命名为 Hexo，在该文件夹下右键鼠标选择 Git Bash Here依次输入一下命令（安装无进度提示，过程需要等待） 1234567$ cd d:/hexo$ npm install hexo-cli -g$ hexo init blog # 创建 blog 文件夹$ cd blog$ npm install$ hexo g$ hexo s 完成以上操作，显示本地的 web 服务器已经启动了，在浏览器中输入 localhost:4000 即可看到默认生成的博客页面了（已经有一篇默认的博文）常用命令：12345$ hexo new &quot;Name&quot; # 创建一篇 blog$ hexo generate # （简写 hexo g） 生成网站$ hexo server # （简写 hexo s） 启动本地服务器$ hexo deploy # （简写 hexo d）$ hexo clean # 清除缓存文件 （db.json） 和已经生成的静态文件（public文件夹） 更多 Hexo 命令 如何写博客通过命令创建一篇博客后，打开 blog 文件夹，该篇博文在 source 文件夹的 _posts 子文件夹下，使用 markdown 编辑器（自行搜索下载）打开该文件即可编辑内容。删除该文件并重新生成网页后该博客就可被删除。了解更多 Markdown 相关内容 如何修改页面上的内容所有可供修改的内容均在 _config.yml 配置文件当中，自行修改对应内容的参数和数据即可。如果你使用了 GitHub 上的不同主题，则需要修改对应主题文件包下的 _config.yml 配置文件 部署到 GitHub Pages不了解 GitHub 的同学在前面安装 git 的时候应该已经初步了解并注册了 GitHub 账号了吧。那么就进行以下步骤： 部署准备(授权本机向 GitHub 提交代码)向 GitHub 提交代码是需要授权的，不能随意提交，GitHub 上一般是基于 SSH 授权的。SSH 是一种网络协议，用于计算机之间的加密登录。Linux 和 Mac 是默认安装了 SSH，Windows系统在安装了 git 之后也是自带 SSH 的。（在 Git Bash 里输入 ssh 出现以下提示说明本机已安装） 继续输入命令 ssh-keygen -t rsa（指定 rsa 算法生成密钥，接着连续三个回车）系统就会生成 id_rsa 和 id_rsa.pub 两个文件（Windows 在c:/Documents and Settings/username/.ssh 下）。前者为本机密钥，后者为公钥，两者配对才能授权成功。 记事本打开 id_rsa.pub 文件，复制内容 在 GitHub 上添加 SSH key 公钥, 点击你的 GitHub 头像，选择 Settings，添加 SSH在红色框内粘贴复制的内容，title可不填 验证是否添加成功 在 GitHub 上创建一个新的 repository PS：repository命名以.github.io结尾时，会自动开启 GitHub Pages 如下图（在仓库的Settings 选项中） 将本地 Hexo 页面部署到 GitHub Pages 步骤一：修改配置文件，找到 _config.yml 文件中的 deploy 部分（用 sublime 等编辑器打开，保证保存的编码为 UTF-8 ）作如下修改（注意冒号后面要有空格） 1234deploy: type: git repo: git@github.com:username/username.github.io.git branch: master 步骤二：安装用于发布的扩展插件（在 blog 目录下） 1$ npm install hexo-deployer-git --save 步骤三：执行命令 $ hexo d 部署原理： 之前步骤中在 GitHub 上创建的那个 repo（username.github.io）一个最大的特点就是其 master 中的 html 静态文件，可以通过链接http://username.github.io来直接访问。 hexo g 会生成一个静态网站（第一次会生成一个 public 目录），这个静态文件可以直接访问。 需要将 hexo 生成的静态网站，提交 (git commit) 到 GitHub 上。 接下来访问你的博客网址，会发现已经变成了之前 Hexo 生成的页面了。简单的博客网站已经搭建完成了，当然，完成以上步骤只是使用了原始 Hexo 框架提供的主题。GitHub上还有很多基于 Hexo的酷炫主题可供修改博客页面。 Hexo 主题配置以我当前主题（indigo）为例。 在 GitHub 上搜索 hexo theme，找到 indigo 在 blog 文件夹下执行以下命令将项目 clone 到本地，这时候 themes 文件夹下会出现该项目文件夹 1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo PS：由于该主题对应环境有要求（node 6.0+，Hexo 3.0+），并且需要一些环境依赖，安装相应插件。具体参考该主题提供的文档 打开 blog 文件夹中的 _config.yml 配置文件，找到 theme 选项，修改为 indigo (项目文件名) 修改主题文件的_config.yml 配置文件，具体修改同样参考文档 重新生成 Hexo 网页并部署到 GitHub Pages上。 至此，博客网站已搭建完成，更多内容修改和功能配置参考主题文档即可。本人非常喜欢这个主题，非常感谢主题开发者：https://github.com/yscoder ，必须给 star 呀。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]}]