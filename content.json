[{"title":"Oracle 学习笔记04","date":"2018-03-29T08:25:10.000Z","path":"2018/03/29/oracle学习笔记04/","text":"1. 视图 视图是数据库对象之一,数据库对象有: 表 , 视图 , 索引 , 序列视图在SLQ中的体现的角色与表相同，但是并非真实的表，它不包含任何数据。它只是对应一个查询语句的结果集所以查询一张视图时，先会执行该视图对应的查询语句得到结果集，然后再根据这个结果集进行实际的查询工作。 简单视图 视图数据来自单一的一张表，且不含有函数或表达式 复杂视图 查询语句含有函数，表达式，分组等 连接视图 视图数据来自多张表，算是复杂视图的一种 创建一个简单视图 , 显示部门 10 的员工信息12345CREATE OR REPLACE VIEW v_emp_dept10ASSELECT empno id, ename name, sal salary,deptnoFROM empWHERE deptno = 10 创建一个复杂视图， 显示 不同部门的工资信息12345678910CREATE OR REPLACE VIEW v_salinfoASSELECT AVG(sal) avg_sal, SUM(sal) sum_sal, MAX(sal) max_sal, MIN(sal) min_sal , e.deptno, d.dnameFROM emp e, dept dWHERE e.deptno = d.deptnoGROUP BY e.deptno, d.dname 注意: 当视图对应的查询语中字段含有函数和或者表达式时,该字段必须给别名 基于上述视图实现查询12345-- 查询工资低于部门平均工资的员工信息SELECT e.ename, e.sal, e.deptnoFROM emp e, v_salinfo vWHERE e.deptno = v.deptnoAND e.sal&lt; v.avg_sal; 删除视图12-- 删除视图并不会删除基表中的数据DROP VIEW v_emp_dept10 2. 视图的DML操作 对视图进行DML操作仅能对简单视图进行 DML 操作，复杂视图不允许进行 DML 操作。 简单视图的DML操作要求 注意不能违反基表的约束条件基表： 视图数据来源的表对视图进行 DML 操作就是对基表进行 DML 操作 向视图对应的基表插入一条 12INSERT INTO v_emp_dept10(id,name,salary,deptno) VALUES (1001，'JACK',5000，10) 更新记录 123UPDATE v_emp_dept10SET salary = 9000WHERE id = 1001; 视图对基表的污染 对视图进行某些 DML 操作时，可能导致视图自身对该记录不可见，但是依然能影响到基表记录，这种操作是对基表的“污染”。（DELETE 操作不会造成该影响） 举例 1：123456--因为视图本身只能查询到 部门10 的数据，所以一下插入的数据对基表修改了，但是视图不可见INSERT INTO v_emp_dept10(id, name, salary, deptno) VALUES ('1002','ROSE',5000,20)--以下操作将视图所能查询到的部门 10 的部门号都改为20，导致基表不存在部门10，再次查询该视图则会没有记录UPDATE v_emp_dept10SET deptno = 20； 如何防止上述情况发生？对视图添加检查选项 添加了检查选项的视图要求对视图进行 DML 操作后，视图必须对其可控：INSERT 后视图必须可见，UPDATE 后视图也必须对其可见，DELETE 不影响 创建视图 指定检查选项 ( WITH CHECK OPTION)123456CREATE OR REPLACE VIEW v_emp_dept10ASSELECT empno id, ename name, sal salary,deptnoFROM empWHERE deptno = 10WITH CHECK OPTION 创建视图 指定只读选项 ( WITH READ ONLY)1234567-- 该视图只能进行查询，不能进行 DML 操作CREATE OR REPLACE VIEW v_emp_dept10ASSELECT empno id, ename name, sal salary,deptnoFROM empWHERE deptno = 10WITH READ ONLY 3 . 序列 数据库对象之一，用来生成一系列数字，通常序列生成的数字是为某张表的主键字段（id）提供值的 创建 从1000 开始，每次自增 10 的序列123CREATE SEQUENCE seq_emp_empnoSTART WITH 1000INCREMENT BY 10 序列支持两个伪列： NEXTVAL : 使序列生成下一个数字，新创建的序列第一次生成是 START WITH 指定的数，以后就是上次生成的数字加上步长得到的。序列不能后退，所以生成新数字后就不能得到以前的数字了 CURRVAL ： 返回序列最后生成的数字， 新创建的序列至少调用一次 NEXTVAL 以后才可以使用CURRVAL12SELECT seq_emp_empno.NEXTVAL FROM dual; -- 第一次执行结果为1000， 以后每次加10SELECT seq_emp_empno.CURRVAL FROM dual; -- 执行后为当前数字 使用序列插入数据（主键自增）1234INSERT INTO emp(empno, ename, job ,sal, deptno)VALUES(seq_emp_empno.NEXTVAL,'jack','CLERK' ,1000,10) 删除序列1DROP SEQENCE sqq_emp_empno 4 . 索引 索引是一种允许直接访问数据表中某一数据行的属性结构，为了提高查询效率而引入的，是独立于表的对象 创建索引1CREATE INDEX idx_emp_ename ON emp(ename) 创建复合索引（多字段）1CREATE index idx_emp_job_sal ON emp(job,sal) 创建基于函数的索引1CREATE INDEX idx_emp_ename_upper ON emp(UPPER(ename)) 在查询 索引 所绑定的字段时，数据库管理软件会自动调用索引以提高效率。 注意：索引不宜创建过多，表的数据量不大时不推荐创建索引。","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"Oracle 学习笔记03","date":"2018-03-29T08:24:50.000Z","path":"2018/03/29/oracle学习笔记03/","text":"Oracle 数据库 ( SQL 高级查询)1. 子查询 子查询就是一条SQL语句,它是嵌套在其他SQL语句中的,目的是为实际的SQL语句提供数据子查询可以应用在 DQL, DDL, DML 中 查看比 CLARK 工资高的员工信息123SELECT ename,sal FROM empWHERE sal &gt; (SELECT sal FROM emp WHERE ename = 'CLARK') 查找和CLARK相同部门的其他员工1234SELECT ename, deptno FROM empWHERE deptno = (SELECT deptno FROM emp WHERE ename='CLARK')AND ename&lt;&gt;'CLARK' 子查询在 DDL 中的应用:可以根据查询结果集快速创建一张表 1234CREATE TABLE myemployee ASSELECT e.empno, e.ename,e.sal,e.job,e.deptno,d.dname,d.locFROM emp e JOIN dept dON e.deptno= d.deptno; 子查询在 DML 中的应用:将CLARK所在部门所有员工的工资加500 123UPDATE empSET sal= sal+500WHERE deptno=(SELECT deptno FROM emp WHERE ename='CLARK') 子查询根据查询结果不同,分为: 单行单列子查询: 常用作过滤条件 多行单列子查询: 常用作过滤条件 多行多列子查询: 常当做表看待 多行单列子查询查看与职位是 SALESMAN 同部门的其他员工 1234SELECT ename, job, deptno FROM empWHERE deptno IN (SELECT deptno FROM emp WHERE job='SALESMAN')AND job &lt;&gt; 'SALESMAN' 多行多列子查询查询比本部门平均工资高的员工信息 12345SELECT e.ename, e.sal, e.deptnoFROM emp e,(SELECT AVG(sal) avg_sal,deptno FROM emp GROUP BY deptno) sWHERE e.deptno = s.deptnoAND e.sal &gt; s.avg_sal 练习:1234567891011121314151617-- 查询4人以上(包含4人)的部门员工的工资是多少-- 方法1SELECT e.ename,e.sal,e.deptnoFROM emp e JOIN (SELECT deptno FROM emp GROUP BY deptno HAVING COUNT(*)&gt;=4 ) dON e.deptno=d.deptno;-- 方法2SELECT ename, sal,deptnoFROM empWHERE deptno IN (SELECT deptno FROM emp GROUP BY deptno HAVING COUNT(*)&gt;=4 );-- 方法3SELECT e.ename,e.sal,e.deptnoFROM emp e,(SELECT COUNT(*) per_num, deptno FROM emp GROUP BY deptno) dWHERE e.deptno = d.deptnoAND d.per_num&gt;=4; EXISTS 关键字 该关键字后面跟一个子查询,用于在 WHERE 中作为过滤条件使用,是用来判断其后的子查询是否可以查出数据,若可以则 EXISTS 返回true, 否则返回 false 查询有员工的部门123SELECT d.deptno , d.dname, d.loc FROM dept dWHERE EXISTS(SELECT *FROM emp e WHERE e.deptno = d.deptno); 查询没有员工的部门123SELECT d.deptno , d.dname, d.loc FROM dept dWHERE NOT EXISTS(SELECT *FROM emp e WHERE e.deptno = d.deptno) 查看有下属的员工的工号,名字,职位,工资123SELECT e.empno, e.ename, e.job,e.salFROM emp eWHERE EXISTS(SElECT *FROM emp m WHERE e.empno=m.mgr ) 2. 分页查询 分页查询是分段查询数据,在查询的数据量非常大的时候尤其重要.分页查询可以减少,系统资源消耗,响应速度快.不同的数据库分页的语法不一致 Oracle中使用 ROWNUM 解决分页,ROWNUM 是一个伪列,不存在于任何一张表中,但是每张表都可以查询该字段.在查询某张表示,只要可以查询出一条记录,该字段的值就是该条记录的行号,从1开始生成的过程在查询过程中进行 举例一:12SELECT ename, sal, deptno FROMWHERE ROWNUM BETWEEN 6 AND 10 以上查询不出任何数据原因: 编号是在查询的过程中进行的,所以不能用 ROWNUM 在编号的过程中进行&gt;1以上的数据的判断,否则查询不出数据 正确的做法:123SELECT ename, sal, deptno FROM(SELECT ROWNUM rn,ename,sal,deptno FROM emp)WHERE rn BETWEEN 6 AND 10 注意 : 子查询中 ROWNUM 必须要指定别名才能保证外层查询使用的是 子查询中的 ROWNUM 举例二 :分页与 ORDER BY查询 工资排名 6 到 10 的员工信息1234567SELECT * FROM(SELECT ROWNUM rn ,t.* FROM (SELECT ename, sal, deptno FROM emp ORDER BY sal DESC) t WHERE ROWNUM &lt;= 10) -- 第10条数据之后不再编号,提高效率WHERE rn BETWEEN 6 AND 10; 若有排序需求,一定要先排序,因为排序操作是在最后执行的. 计算分页公式page : 页号pageSize : 每页的条目数 start : ( page - 1 ) * pageSize + 1 end : pageSize * page 3 . 排序函数 排序函数允许按照指定字段分组, 再按照指定字段排序, 然后生成组内编号 ROW_NUMBER () 生成组内连续且唯一的数字查看每个部门的工资排名: 123456SELECT ename, sal, deptno, ROW_NUMBER() OVER(PARTITION BY deptno ORDER BY sal DESC)FROM emp; RANK () 生成组内不连续也不唯一的数字查看每个部门的工资排名(允许相同名次): 123456SELECTename,sal,deptno,RANK() OVER( PARTITION BY deptno ORDER BY sal DESC)FROM emp; DENSE_RANK () 生成组内连续但不唯一的数字查看每个部门的工资排名(允许相同名次,但名次不跳跃): 123456SELECTename,sal,deptno,DENSE_RANK() OVER( PARTITION BY deptno ORDER BY sal DESC )FROM emp; 4. DECODE 函数 DECODE 函数用于比较的 参数 1若匹配 参数 2 则 返回参数 3若匹配 参数 4 则 返回参数 5… 最后一个默认值 查询职员的职位来计算奖金12345678910SELECTename,job ,sal,DECODE(job, 'MANAGER',sal*1.2, 'ANALYST',sal*1.1, 'SALESMAN', sal*1.05) bonusFROM emp; 计算指定类别职位的人数如:指定 MANAGER 和 ANALYST 为 VIP , 其他为 OPERATION, 分别统计这两类职位的人数123456789101112SELECT DECODE(job, 'ANALYST','VIP', 'MANAGER','VIP', 'OPERATION' ) job, COUNT(*) job_cntFROM empGROUP BY DECODE(job, 'ANALYST','VIP', 'MANAGER','VIP', 'OPERATION' ) 5 . 集合操作 UNION : 获取结果集并集,并去除重复 UNION ALL : 获取结果集并集,但不去重 INTERSECT : 获取结果集交集 MINUS : 获取结果集的差集(结果集 1 中存在, 结果集 2 中不存在) 示例:(两个查询子句的查询字段必须相同)12345SELECT ename,job,sal FROM empWHERE job = 'MANAGER'UNION -- 这里替换其他集合操作SELECT ename,job,sal FROM empWHERE sal&gt;2500 6 . 高级分组函数 ROLLUP() 分组情况递减GROUP BY ROLLUP(a , b , c) 等同于 1234567SELECT... GROUP BY a, b ,cUNION ALLSELECT... GROUP BY a, b UNION ALLSELECT... GROUP BY aUNION ALL全表 CUBE() 分组情况全排列GROUP BY CUBE0(a , b , c) 等同于 (内部实现并非 UNION ALL, 效率更高但效果相同) : 123456789101112131415SELECT... GROUP BY a, b , cUNION ALLSELECT... GROUP BY a, b UNION ALLSELECT... GROUP BY a, cUNION ALLSELECT... GROUP BY cUNION ALLSELECT... GROUP BY b, c UNION ALLSELECT... GROUP BY bUNION ALLSELECT... GROUP BY cUNION ALL全表 GROUPING SETS() 自定义分组如:SELECT... GROUP BY GROUPING SETS((year, month), (month))指定 123SELECT... GROUP BY year , monthUNION ALLSELECT.. GROUP BY month","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"Oracle 学习笔记02","date":"2018-03-20T05:06:48.000Z","path":"2018/03/20/oracle学习笔记02/","text":"Oracle 数据库( SQL基础查询)1. 基本查询语句 使用别名 当一个SELECT 子句中查询的内容是一个函数或者表达式, 那么在结果集中对应的该字段的字段名就是这个函数表达式,可读性差,为此应当为该列添加别名 SELECT ename , sal*12 salary FROM emp或SELECT ename , sal*12 AS salary FROM emp别名不区分 大小写,若希望区分大小写,或者别名中含有空格,可以使用双引号包围SELECT ename , sal*12 &quot;sa A lary&quot; FROM emp; 2. 查询条件 使用 &lt; , &gt; , &lt;&gt;(不等于)SELECT ename, sal FROM emp WHERE sal&lt; 2000 SELECT ename,sal,job FROM emp WHERE deptno &lt;&gt; 10; SELECT ename,sal,hiredate FROM emp WHERE hiredate &gt;TO_DATE(&#39;1982-01-01&#39;,&#39;YYYY_MM_DD&#39;) AND, OR 关键字SELECT ename, sal, job FROM emp WHERE sal &gt; 1000 AND job=&#39;CLERK&#39; SELECT ename, sal, job FROM emp WHERE sal &gt; 1000 OR job=&#39;CLERK&#39; AND 的优先级高于 OR 所以,可以通过添加括号来提高OR的优先级 SELECT ename, sal, job FROM emp WHERE sal &gt; 1000 AND (job=&#39;SALESMAN&#39; OR job=&#39;CLERK&#39;) LIKE 条件 LIKE 用于模糊匹配字符串,它需要借助两个通配符: % : 表示 0 到 多个字符 _ : 表示单个字符 查看员工第二个字符是 A 的员工: SELECT ename, job, sal FROM emp WHERE ename LIKE &#39;_A%&#39; IN (List) , NOT IN (List) 判断在列表中,不在列表中,常用于子查询中 SELECT ename, job, sal FROM emp WHERE job IN (&#39;MANAGER&#39;,&#39;CLERK&#39;) BETWEEN…AND… 查询符合某个值域范围的数据 SELECT ename,sal FROM emp WHERE sal BETWEEN 1500 AND 3000 使用 ANY 和 ALL 条件 用于判断诸如 : &gt; , &gt;= , &lt; , &lt;= 一个列表的内容&gt;ALL(list) : 大于列表中所有的 ( 大于最大的)&gt;ANY(list) : 大于列表中之一即可 ( 大于最小的) 以下查询结果相同:SELECT empno, ename, job, sal, deptno FROM emp WHERE sal &gt; ALL(1500,2500,2000)SELECT empno, ename, job, sal, deptno FROM emp WHERE sal &gt; ANY(2500,4500,4000) ANY 和 ALL 的列表通常不会给特定的值,这样没有意义,通常使用在判断一个子查询的结果 查询条件中使用表达式和函数SELECT ename, sal, job FROM emp WHERE ename = UPPER(&#39;scott&#39;)SELECT ename, sal, job FROM emp WHERE sal*12&gt;50000 DISTINCT 过滤重复 去除后面指定字段的重复行,必须紧跟在 SELECT 关键字之后 查看员工职位种类数SELECT DISTINCT job FROM empDISTINCT 后面可以跟多个字段: 这些字段值的组合没有重复以下查询不会出现 同一部门相同职位 的人SELECT DISTINCT job, deptno FROM emp 3. 排序 ORDER BY 排序 可以根据后面指定的字段对结果集进行升序或降序排列,其中 ASC 是升序, DESC 是降序,通常不写 ASC ,默认升序 ORDER BY 子句只能存在 SELECT 语句中最后一个子句上SELECT ename, sal FROM emp ORDER BY sal ORDER BY 可以按照多个字段排序,排序是有优先级的,首先按照第一个字段的排序规则偶像,当第一个字段有重复值时,才按照第二个字段排序 SELECT ename, deptno, sal FROM emp ORDER BY deptno, sal DESC 4. 聚合函数 聚合函数又称为多行函数,分组函数,聚合函数可以将多条记录进行统计,然后得出一个结果.所以聚合函数是用来统计使用的 MAX() 和 MIN () : 统计最大值和最小值查看公司的最高工资是多少SELECT MAX(sal) FROM emp AVG() 和 SUM() : 求平均值,总和SELECT AVG(sal) FROM empSELECT SUM(sal) FROM emp COUNT() : 统计记录总数SELECT COUNT(ename) FROM emp 注意: 聚合函数忽略 NULL 值举例: SELECT AVG(comm) FROM emp上述查询,如果comm字段存在 NULL 值则除数不符合实际值,结果不正确解决: SELECT AVG(NVL(comm,0)) FROM emp 5. 分组 GROUP BY 子句 可以将结果集按照指定的字段值相同的记录看做是一组,配合聚合函数使用可以对不同分组的记录分别进行统计然后得到结果 查看每个部门最高工资和最低工资SELECT MAX(sal) , MIN(sal) FROM emp GROUP BY deptno 在 SELECT 当中若使用了聚合函数,那么不在聚合函数中的其他单独字段必须出现在 GROUP BY 子句中,反过来不是必须的GROUP BY 也可以按照多个字段进行分组,分组原则是这些字段值的组合相同的看做一组 查看每个部门每种职位的平均工资SELECT AVG(sal), deptno||job FROM emp GROUP BY deptno, job WHERE 的过滤时机: WHERE 是在查询表中每一条数据是进行过滤的,只会将满足 WHERE 条件的记录查询出来 ,所以聚合函数无法使用在 WHERE 后, 解决的该问题可以用 HAVING 子句 HAVING 子句 HAVING 子句必须紧跟在GROUP BY 子句之后,作用是添加条件来过滤不同的分组, HAVING 可以用聚合函数作为过滤条件 查看平均工资高于2000的部门 的平均工资 123SELECT AVG(sal) FROM empGROUP BY deptnoHAVING AVG(sal)&gt;2000 查看平均工资高于2000 的部门的最高和最低工资 123SELECT MAX(sal) , MIN(sal), deptno FROM empGROUP BY deptnoHAVING AVG(sal)&gt;2000 查看最高工资&gt;=3000 的职位的平均工资 123SELECT AVG(sal) , job FROM empGROUP BY jobHAVING MAX(sal)&gt;=3000 SQL 关联查询 关联查询时间建立在多张上进行联合查询 查询的结果集中,每一条记录中的字段可能来自不同的表 重点: 找到表与表的记录之间的对应关系 查询每个员工的基本信息及其部门信息123SELECT e.ename, e.job, e.sal , d.dname, d.loc, d.deptnoFROM emp e, dept dWHERE e.deptno = d.deptno 上述 SQL 中: e.deptno = d.deptno 条件是用来联系 emp 和 dept 的数据关系的,这样的条件称为连接条件 在关联查询中,必须要添加连接条件,N 张表关联查询至少要添加 N-1 连接条件.不添加连接条件,会产生笛卡尔积 ( 实际开发要避免 ) 关联查询的连接条件与过滤条件要同时成立 1234SELECT e.ename , e.job, e.sal, e.deptno,d.dnameFROM emp e, dept dWHERE e.deptno = d.deptnoAND d.dname='SALES' 内连接关联查询的另一种写法 123SELECT e.ename, d.dnameFROM emp e JOIN dept dON e.deptno= d.deptno 这样写的好处是 过滤条件和连接条件分开 ,结构更明确 123 SELECT e.ename, d.dnameFROM emp e JOIN dept dON e.deptno= d.deptno 外连接 内连接返回满足连接条件的数据记录,而如果需要将不满足连接条件的记录返回,则需要使用外连接 左外连接: 以 JOIN 左侧的表为驱动表,该表所有记录都要显示出来,那么当某条记录不满足连接条件时,来自 JOIN 右侧表中的字段的值全部为 NULL 123SELECT e.ename,e.sal, d.dname ,d.locFROM emp e LEFT OUTER JOIN dept dON e.deptno= d.deptno 右外连接 : 以 JOIN 右侧的表为驱动表,其他特性同上RIGTH OUTER JOIN ...ON... 全外连接 : JOIN 两侧的表都为驱动表,综合左右外连接内容FULL OUTER JOIN...ON... 自连接 当前表的一条记录对应当前表本身的多条记录, 这种设计就是自连接,自连接是用来解决数据内容相同,但是数据间又存在上下级关系的树状结构情况 查找每个员工及其上司的名字 12SELECT e.ename worker, m.ename manager FROM emp e,emp mWHERE e.mgr = m.empno 上述结果采用内连接 12SELECT e.ename worker, m.ename manager FROM emp e JOIN emp mON e.mgr = m.empno","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"Oracle 学习笔记01","date":"2018-03-20T05:06:48.000Z","path":"2018/03/20/oracle学习笔记01/","text":"Oracle 数据库修改表 修改表名RENAME old_name TO new_name 修改表结构 添加列为 myemp 添加一列 hiredate :ALTER TABLE myemp ADD (hiredate DATE DEFAULT SYSDATE ) 删除列删除上面添加的字段ALTER TABLE myemp DROP(hiredate) 修改列ALTER TABLE myemp MODIFY(job VARCHAR2(40) DEFAULT &#39;CLERK&#39;) DML 语句 DML 可以对表中的数据进行操作,分为 : INSERT, UPDATE , DELETEDML 是伴随事务 ( Transaction ) 使用的. ####1. INSERTINSERT INTO myemp (id, name, salary, job) VALUES (1, &#39;jack&#39;, 5000, &#39;CLERK&#39; )若不指定字段,则需全列插入INSERT INTO myemp VALUES(...)插入一个日期值INSERT INTO myemp (id, name, salary, birth, job) VALUES (2, &#39;tom&#39;, 3000, TO_DATE(&#39;2008-08-08&#39;,&#39;YYYY-MM-DD&#39;)) 2. UPDATE修改表中现有数据UPDATE myemp SET gender=&#39;F&#39;, salary=9000 WHRER name=&#39;jack&#39; 3. DELETE删除数据通常使用时添加 WHERE 条件,不添加则是清空表 DQL 语句1. SELECT 查看表中所有字段及其记录SELECT * FROM emp查看表中的某几个字段SELECT ename, job, sal FROM empSELECT 子句可以查看:字段,函数,表达式SELECT ename, sal*12 FROM empSELECT 子句结合 WHERE 子句SELECT ename, job,sal,deptno FROM emp WHERE deptno=20 字符串函数 CONCAT(P1,P2) : 字符串拼接SELECT CONCAT(ename, sal) FROM emp; p1 || p2 || p3: 多字符拼接SELECT ename||&#39;:&#39;||sal FROM emp LENGTH (p): 获取字符串长度SELECT ename, LENGTH(ename) FROM emp LOWER, UPPER, INICAP :小写,大写,首字母大写SELECT LOWER(&#39;HELLO WORLD&#39;), UPPER(&#39;helloworld&#39;), INITCAP(&#39;hello world&#39;) FROM dual 伪表 : dual当查询内容与任何一张表无关时,为了满足 FROM子句的要求,可以使用伪表,伪表只会查出一条语句 TRIM , LTRIM, RTRIM:去除字符串两边内容 (注意语法)SELECT TRIM(&#39;e&#39; FROM &#39;eeeeliteeee&#39;) FROM empSELECT LTRIM(&#39;esesesliteeee&#39;,&#39;es&#39;) FROM dualSELECT RTRIM(&#39;eeeeliteeee&#39;,&#39;e&#39;) FROM dual LPAD, RPAD 补位函数,可以将指定内容指定位数,不足时则补充若干个指定的定义字符以达到位数 SELECT LPAD(sal,6,&#39;$&#39;) FROM empSELECT RPAD(sal,6,&#39; &#39;) FROM emp SUBSTR(str,m[,n]) 截取字符串 str 从m处开始,,连续截取n个,若不指定n,则是连续截取到字符串末尾注意:数据库中下标从 1 开始 SELECT SUBSTR(&#39;thinking in java&#39;,10,2) FROM dual INSTR(str1, str2 [,n [,m]]) 查找位置 : 查找 str2 在 str1 中的位置,若指定了位置 n 从 n 处开始查找第一次出现的位置,若指定了 m 则是查找第 m 次出现的位置 SELECT INSTR(&#39;thinking in java&#39;,&#39;in&#39;,4,2) FROM dual 数值函数 ROUND(n [,m]) 对 n 进行四舍五入, m 是保留到小数点后多少位, 若 m 为 0 或不指定,则保留整数,若 m 为负数, 则是保留小数点前的位数 SELECT ROUND(45.678 , 2), ROUND(45.678) FROM dualSELECT ROUND(45.678 , -1), ROUND(55.678, -2),ROUND(45.76, -2) FROM dual TRUNC(n,[,m]) 数字截取函数,对 n 截取 m 位 SELECT TRUNC(45.678, 2), TRUNC(45.678), TRUNC(55.678, -1) FROM dual MOD(n, m) 求余数,若 m 为 0 ,则直接返回 n SELECT MOD(13,4) FROM dual CEIL(n)和 FLOOR(n) 向上取整,向下取整 SELECT CEIL(45.67) , FLOOR(45.67) FROM dual 日期类型 DATE 与 TIMESTAMP 两者都是常用的日期类型, DATE 为7个字节,TIMESTAMP 为11个字节,多出来的4个字节用来表示秒以下的精度 日期相关关键字 SYSDATE : 表示一个内部函数,返回一个表示当前系统时间的 DATE 类型的值SYSTIMESTAMP : 返回时间戳类型的当前系统时间 日期类型比较大小 越晚的越大,日期可以进行加减运算,加上一个数字等于加上指定的天数,减法同理.两个日期相减,差为相差的天数 查看每个员工入职天数(取整)SELECT ename, CEIL(SYSDATE-hiredate) FROM emp 查看 1982-1-1 以后入职的员工SELECT ename, hiredate FROM emp WHERE hiredate &gt; TO_DATE(&#39;1982-01-01&#39;,&#39;YYYY-MM-DD&#39;); TO_DATE() 可以将一个字符串按照指定的日期格式转换成DATE RR : 两位数字表示年,会自动判定世纪1950-02-04SELECT TO_CHAR(TO_DATE(&#39;50-02-04&#39;,&#39;RR-MM-DD&#39;),&#39;YYYY-MM-DD&#39;) FROM dual2049-02-04SELECT TO_CHAR(TO_DATE(&#39;49-02-04&#39;,&#39;RR-MM-DD&#39;),&#39;YYYY-MM-DD&#39;) FROM dual TO_CHAR() 可以将日期按照指定日期格式转换为字符串SELECT TO_CHAR(SYSDATE,&#39;YYYY-MM-DD HH12:MI:SS&#39;) FROM dual 注意: 日期格式字符串中,出现的字符凡是不是英文与符号,其他字符全部要使用双引号包围SELECT TO_CHAR(SYSDATE,&#39;YYYY&quot;年&quot;MM&quot;月&quot;DD&quot;日&quot;&#39;) FROM dual LAST_DAY(date) 返回给定日期所在月的月底日期 SELECT LAST_DAY(SYSDATE) FROM dual ADD_MONTHS(date , i) 返回日期date 加上 i 个月后的日期值 查看每个员工入职20周年纪念日 SELECT ename, ADD_MONTHS(hiredate,20*12) FROM emp MONTHS_BETWEEN (date1, date2) 查看两个日期之间相差多少月 每个职工入职多少个月SELECT ename, MONTHS_BETWEEN(SYSDATE, hiredate) FROM emp NEXT_DAY(date , i) 返回给定日期之后一周内的周几对应的日期 SELECT NEXT_DAY(SYSDATE,4) FROM dual LEAST,GREATEST 返回参数列表中 最小值 和 最大值 SELECT LEAST(SYSDATE, TO_DATE(&#39;2008-08-08&#39;,&#39;YYYY-MM-DD&#39;)) FROM dual 82 年以前返回1982-1-1, 82年以后返回入职日期SELECT ename, GREATEST(hiredate, TO_DATE(&#39;1982-01-01&#39;,&#39;YYYY-MM-DD&#39;)) FROM emp EXTRACT 提取一个日期中指定的时间分量 SELECT EXTRACT(YEAR FROM SYSDATE) FROM dual查看1982年入职的员工SELECT ename, hiredate FROM emp WHERE EXTRACT(YEAR FROM hiredate )=1982 NULL NULL 的运算 与字符串连接等于什么也没做 与数字运算结果还是 NULL NVL(p1, p2) 当 p1 为 NULL 时,函数返回 p2, 若 p1 不为 NULL ,则函数返回 p1 本身 SELECT ename ,sal, comm,sal+NVL(comm, 0 ) FROM emp NVL2(p1, p2 , p3) 若 p1 为 NULL 则返回 p3, 若 p1 不为 NULL 则返回 p2根据com字段是否为 NULL 判断有没有奖金 SELECT ename, NVL2(comm,&#39;有奖金&#39;,&#39;没奖金&#39;) FROM emp","tags":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/tags/数据库/"}]},{"title":"基于 Hexo + GitHub Pages 搭建个人博客","date":"2017-11-29T16:06:48.000Z","path":"2017/11/30/基于-Hexo-GitHub-Pages-搭建个人博客/","text":"前言之前一直想弄个自己的个人博客，记录自己的学习历程。看了很多网站，像 CSDN 、博客园 、简书也都有博客专栏，总感觉不够个性化，但自己撸一个网站苦于前端技术太渣，耗时耗力还不讨喜。于是折中选择使用 Hexo + GitHub 来搭建这个个人博客，也顺便熟悉一下 git 的基本知识。 什么是 Hexo Hexo 是一款基于 Node.js 的静态博客框架，可以生成静态网页托管在 GitHub 和 Heroku 上。Hexo 使用 Markdown （或其他渲染引擎）解析文章，在几秒内即可利用靓丽的主题生成静态网页（简直是前端小白福音啊） Hexo 官网 如何使用 Hexo前面说了 Hexo 是基于 Node.js 的，所以需要系统中安装 Node.js。因为博客是托管在 GitHub 上的，所以还要安装 git 安装 Node.js下载 Node.js安装教程 安装 git （按照默认设置的安装就好）下载 git对于 git 或者 不了解 GitHub 的同学点击 stormzhang的博客，本文不扩展这部分内容了 安装 Hexo新建一个文件夹命名为 Hexo，在该文件夹下右键鼠标选择 Git Bash Here依次输入一下命令（安装无进度提示，过程需要等待） 1234567$ cd d:/hexo$ npm install hexo-cli -g$ hexo init blog # 创建 blog 文件夹$ cd blog$ npm install$ hexo g$ hexo s 完成以上操作，显示本地的 web 服务器已经启动了，在浏览器中输入 localhost:4000 即可看到默认生成的博客页面了（已经有一篇默认的博文）常用命令：12345$ hexo new &quot;Name&quot; # 创建一篇 blog$ hexo generate # （简写 hexo g） 生成网站$ hexo server # （简写 hexo s） 启动本地服务器$ hexo deploy # （简写 hexo d）$ hexo clean # 清除缓存文件 （db.json） 和已经生成的静态文件（public文件夹） 更多 Hexo 命令 如何写博客通过命令创建一篇博客后，打开 blog 文件夹，该篇博文在 source 文件夹的 _posts 子文件夹下，使用 markdown 编辑器（自行搜索下载）打开该文件即可编辑内容。删除该文件并重新生成网页后该博客就可被删除。了解更多 Markdown 相关内容 如何修改页面上的内容所有可供修改的内容均在 _config.yml 配置文件当中，自行修改对应内容的参数和数据即可。如果你使用了 GitHub 上的不同主题，则需要修改对应主题文件包下的 _config.yml 配置文件 部署到 GitHub Pages不了解 GitHub 的同学在前面安装 git 的时候应该已经初步了解并注册了 GitHub 账号了吧。那么就进行以下步骤： 部署准备(授权本机向 GitHub 提交代码)向 GitHub 提交代码是需要授权的，不能随意提交，GitHub 上一般是基于 SSH 授权的。SSH 是一种网络协议，用于计算机之间的加密登录。Linux 和 Mac 是默认安装了 SSH，Windows系统在安装了 git 之后也是自带 SSH 的。（在 Git Bash 里输入 ssh 出现以下提示说明本机已安装） 继续输入命令 ssh-keygen -t rsa（指定 rsa 算法生成密钥，接着连续三个回车）系统就会生成 id_rsa 和 id_rsa.pub 两个文件（Windows 在c:/Documents and Settings/username/.ssh 下）。前者为本机密钥，后者为公钥，两者配对才能授权成功。 记事本打开 id_rsa.pub 文件，复制内容 在 GitHub 上添加 SSH key 公钥, 点击你的 GitHub 头像，选择 Settings，添加 SSH在红色框内粘贴复制的内容，title可不填 验证是否添加成功 在 GitHub 上创建一个新的 repository PS：repository命名以.github.io结尾时，会自动开启 GitHub Pages 如下图（在仓库的Settings 选项中） 将本地 Hexo 页面部署到 GitHub Pages 步骤一：修改配置文件，找到 _config.yml 文件中的 deploy 部分（用 sublime 等编辑器打开，保证保存的编码为 UTF-8 ）作如下修改（注意冒号后面要有空格） 1234deploy: type: git repo: git@github.com:username/username.github.io.git branch: master 步骤二：安装用于发布的扩展插件（在 blog 目录下） 1$ npm install hexo-deployer-git --save 步骤三：执行命令 $ hexo d 部署原理： 之前步骤中在 GitHub 上创建的那个 repo（username.github.io）一个最大的特点就是其 master 中的 html 静态文件，可以通过链接http://username.github.io来直接访问。 hexo g 会生成一个静态网站（第一次会生成一个 public 目录），这个静态文件可以直接访问。 需要将 hexo 生成的静态网站，提交 (git commit) 到 GitHub 上。 接下来访问你的博客网址，会发现已经变成了之前 Hexo 生成的页面了。简单的博客网站已经搭建完成了，当然，完成以上步骤只是使用了原始 Hexo 框架提供的主题。GitHub上还有很多基于 Hexo的酷炫主题可供修改博客页面。 Hexo 主题配置以我当前主题（indigo）为例。 在 GitHub 上搜索 hexo theme，找到 indigo 在 blog 文件夹下执行以下命令将项目 clone 到本地，这时候 themes 文件夹下会出现该项目文件夹 1git clone git@github.com:yscoder/hexo-theme-indigo.git themes/indigo PS：由于该主题对应环境有要求（node 6.0+，Hexo 3.0+），并且需要一些环境依赖，安装相应插件。具体参考该主题提供的文档 打开 blog 文件夹中的 _config.yml 配置文件，找到 theme 选项，修改为 indigo (项目文件名) 修改主题文件的_config.yml 配置文件，具体修改同样参考文档 重新生成 Hexo 网页并部署到 GitHub Pages上。 至此，博客网站已搭建完成，更多内容修改和功能配置参考主题文档即可。本人非常喜欢这个主题，非常感谢主题开发者：https://github.com/yscoder ，必须给 star 呀。","tags":[{"name":"Hexo","slug":"Hexo","permalink":"http://yoursite.com/tags/Hexo/"},{"name":"GitHub","slug":"GitHub","permalink":"http://yoursite.com/tags/GitHub/"}]}]